# Random Notes

* When computing number of subsets, it's 2^N and should be using bitmask
* __builtin_popcount(unsigned int) in the GNU C++ compiler calculates the number of 1s in a binary number (Integer.bitCount(i, j) in Java)
* std::bitset is useful for bit related stuffs
* stoi() can specify a base in the 3rd parameter
* puts() is like the most useful thing ever why have i not used it what
* greater<int> is a useful comparator function template for specifying for data structures to sort descending (ex. set<int, greater<int>)
* A.erase(unique(A.begin(), A.end()), A.end()); // make vector have only unique elements
* For C++, string.split(" ") from Java can be implemented with istringstream ss(str), and then do ss >> var to get the first string, and so on (like cin).
* C++ compilers optimize sequential array searching (row, not column), so use that when possible.
* Column searching has performance hits especially when iterating over sizes that are powers of 2 (https://stackoverflow.com/questions/12264970/why-is-my-program-slow-when-looping-over-exactly-8192-elements?rq=1)
* To specify comparator for a struct, use the operator== override
* Example: `
struct loc {
    int x, y, vx, vy;
    bool operator==(const loc& l) const {
        return (this->x == l.x && this->y == l.y && this->vx == l.vx && this->vy == l.vy);
    }
};
`

## Hashing
* Can use C++ std::hash<T>()(value) to hash values
* Can quickly hash multiple values with XOR (^) (hash<T>()(value) ^ hash<T>()(value2))
* Example: `
struct hashing {
    size_t operator()(const loc& l) const {
        return (hash<int>()(l.x) ^ hash<int>()(l.y) ^ hash<int>()(l.vx) ^ hash<int>()(l.vy));
    }
};
` 

## Shoelace Theorem

## Pick's Theorem

## Set
* Internally stores elements as a balanced binary tree (fast queries with binary search using lower_bound and upper_bound).
* By default sorts the elements by ascending order.
* Does not allow duplicate elements.
* Useful for inserting and deleting elements in logarthmic time.
* Can compress points on a cartesian plane by inserting them into a set, and mapping it to indexes

## Sweep line Algorithm

## Kruskal's vs. Prim's
* Prim's has to be used instead of Kruskal's when getting a subset of the minimum spanning tree

## Bitmask
* ~ - COMPLIMENT (flips bit)
* & - AND
* | - OR
* ^ - XOR

## Sequence DP

## DP on the Interval

## Storing states in DP (2D Array)

## Prefix Sum 
* Also prefix max, and suffix max

## Prefix Sum vs Segment Tree
* Different ways to query sums (O(1) vs. O(nlogn))

## Binary Indexed Tree (Fenwick Tree)

## Adjacency List

## Set
* A list of values in an unique order, and is stored as a binary search tree.

## Priority Queue
* When you edit values of a priority queue, the queue is not automatically updated (or ordered)

## Segment Tree (Range Query)

It's effectively a binary tree!
<br>
[Link to Article] (https://www.geeksforgeeks.org/segment-tree-set-1-sum-of-given-range/)

## Disjoint set (Union Find)

## Cross + Dot Product
* Dot Product: The length of the "shadow" or "projection" that one vector has on another when put on a common point.
* Use it to find the angle between two vectors, by moving both's origin to the point of origin (0, 0)
* Use to determine if several points are on the same line without division (cross product)
* http://www.hackerearth.com/practice/notes/computational-geometry-i-1

## Trie

## Sparse Table

## Lowest Common Ancestor

## Linear Recurrence (fibonacci)

## Dijkstra
   The notion of "relaxation" comes from an analogy between the estimate of the shortest path and the length of a helical tension spring, which is not designed for compression. Initially, the cost of the shortest path is an overestimate, likened to a stretched out spring. As shorter paths are found, the estimated cost is lowered, and the spring is relaxed. Eventually, the shortest path, if one exists, is found and the spring has been relaxed to its resting length.

## Bipartite Graph

## SPFA

## Floyd-Warshall
* aka all pairs shortest path

## Ford-Fulkerson (Edmonds-Karp) Max Flow

## Topological Sort

## Bucket grouping (Dijkstra)

## Tree Style DP

## SCC (Strongly Connected Components)

## Catalan Numbers
## duowei 1265, 1350, 1457
